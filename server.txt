//connect to modules express and sqlite3, enable cors (data sending thingy of node.js)
const express = require('express');
const socketIo = require('socket.io');
const bodyParser = require('body-parser');
const sqlite3 = require('sqlite3').verbose();


const app = express();
const http = require('http');
const server = http.createServer(app);
const io = socketIo(server);



const cors = require('cors');
const { LIMIT_FUNCTION_ARG } = require('sqlite3');
app.use(cors());
app.use(bodyParser.json());

// connect to us client
// connect to us client
app.get('/', (req, res) => {
  res.sendFile(__dirname + 'C:/Users/Eszti/Svelte/src/client.js');
});


//DB------------------------------------
// create the db, accounts is the beta test
let db = new sqlite3.Database('Sagvari.db');
let table =""

let tableStructures = {
  rolls : "(id INTEGER PRIMARY KEY, history TEXT, pity4S INTEGER, pity5S INTEGER, pityUR INTEGER)",
  account : "(id INTEGER PRIMARY KEY, username TEXT, email TEXT, level INTEGER, xp INTEGER, gachaCurrency INTEGER, tickets INTEGER)",
  lobby : "(id INTEGER PRIMARY KEY, username TEXT, level INTEGER)",
  deck : "(id  INTEGER PRIMARY KEY, deckarray TEXT)"

}


// Initialize the database with a table if it doesn't exist
db.run(`CREATE TABLE IF NOT EXISTS account ${tableStructures.account}`);
db.run(`CREATE TABLE IF NOT EXISTS rolls ${tableStructures.rolls}`);
db.run(`CREATE TABLE IF NOT EXISTS lobby ${tableStructures.lobby}`);
db.run(`CREATE TABLE IF NOT EXISTS deck ${tableStructures.deck}`);




//SOCKET-----------------------------

//io.emit('update', n); 
function getValueFromDB(columnName,id,tableName){
  db.get(`SELECT ${columnName} FROM ${tableName}`,(err, row) => {
    //console.log("rows: ",row);
    if(columnName == "*"){
      console.log("sent: "+columnName,row);
      io.emit(columnName, row)
      
    }
    else if(columnName != ""){
      console.log("sent: "+columnName,row[columnName]);
      io.emit(columnName, row[columnName])
      
    }
    //console.log("result: ",result);
  });
}
function getLobbyParties(columnName,id,tableName){
  db.all(`SELECT * FROM lobby`,(err, row) => {
    console.log("emited: ",row);
    io.emit("*", row)
  });
}

// Socket.io connection event
io.on('connection', (socket) => {
  console.log('A user connected');

  //socket.on('tickets', msg => {
    //console.log("server got: ",msg);
    //getValueFromDB(msg.column,msg.id,msg.table)
  //})
  
  var columnNames
  db.all(`PRAGMA table_info(account)`, [], (err, rows) => {
    // Extract and print the column names
    //console.log("rows: ",rows);
    columnNames = rows.map(row => row.name);
    for (let i = 0; i<columnNames.length;i++){
      socket.on(columnNames[i], msg => {
        console.log("server got: ",msg);
        getValueFromDB(msg.column,msg.id,msg.table)
      })
    }
  });

  db.all(`PRAGMA table_info(deck)`, [], (err, rows) => {
    // Extract and print the column names
    //console.log("rows: ",rows);
    columnNames = rows.map(row => row.name);
    for (let i = 0; i<columnNames.length;i++){
      socket.on(columnNames[i], msg => {
        console.log("server got: ",msg);
        getValueFromDB(msg.column,msg.id,msg.table)
      })
    }
  });

  socket.on("*", msg => {
    console.log("server got: ",msg);
    getLobbyParties(msg.column,msg.id,msg.table)
  })

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('A user disconnected');
  });

});





//NODE.JS---------------------------------------
//DIFFERENT ANSWERS TO CLIENT
//
//(the function(err)... is a syntax thingy, as far as i know it doesnt work without it, its the same for every function dm them)

let dataFromClient = null;

// Handle POST request to change data in db
app.post('/sendData', (req, res) => { //the '/xy' ('/sendData' here) is esentially the id of the "function", via that can the client connect to it (if that means sense)
  dataFromClient = req.body; //req.body is the shit we sent (an object usually)
  const query = `UPDATE ${dataFromClient.table} SET (${dataFromClient.column}) = (?) WHERE id = (?)`; //basic sql, format is db.run(sql,data (in place of the ?), function(err)...)
  db.run(query,[dataFromClient.data,dataFromClient.id], function (err) {
    if (err) {
      console.error(err.message);
      res.status(500).send(`Error storing data in ${dataFromClient.column}`);
    } else {
      res.sendStatus(200);
    }
  });
});


// Handle GET request to retrieve data (the db, currently)
app.post('/getData', (req, res) => {
  dataFromClient = req.body
  if(dataFromClient.id != 0){ //if id = 0 we send the whole table over : just a specific item, (also if column is * we send all colums over obv)
    db.all(`SELECT ${dataFromClient.column} FROM ${dataFromClient.table} WHERE id = (?)`,dataFromClient.id, (err, rows) => {
      if (err) {
        console.error(err.message);
        res.status(500).send('Error fetching data from the database');
      } else {
        res.json({ data: rows });
        //console.log(rows);
      }
    });
  }
  else {
    db.all(`SELECT ${dataFromClient.column} FROM ${dataFromClient.table}`, (err, rows) => {
      if (err) {
        console.error(err.message);
        res.status(500).send('Error fetching data from the database');
      } else {
        res.json({ data: rows });
        //console.log(rows);
      }
    });
  }
  
});

//add empty row
app.post('/api/add-row',(req,res) => {
  table = req.body.table;
  console.log("table:"+table + "req.body: " + req.body);
  db.run(`INSERT INTO ${table} DEFAULT VALUES`, function (err) {
    if (err) {
      console.error(err.message);
      res.status(500).send('Error');
    } else {
      res.sendStatus(200);
    }
  });
});


//delte all
app.post('/delTable', (req, res) => {
  table = req.body.table
  db.run(`DROP TABLE ${table}`, function (err) {
  if (err) {
    console.error(err);
    return res.status(500).json({ error: 'Database error' });
  }


  db.run(`CREATE TABLE IF NOT EXISTS rolls ${tableStructures[table]}`);

  

  res.json({ message: 'All rows deleted successfully' });
  });
});

server.listen(3000, () => {
  console.log("Server listening on http://localhost:3000");
});